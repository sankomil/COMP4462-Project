# -*- coding: utf-8 -*-
"""Task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jSrSUJtL6wbg3rFAE4TbWgdMWNqjL5pj
"""

# Commented out IPython magic to ensure Python compatibility.
# installing libraries and packages to load in 
!pip install squarify
import numpy as np
import pandas as pd
from scipy import stats
import squarify as sq
import matplotlib.pyplot as plt
from pandas.plotting import scatter_matrix
import seaborn as sns
import sklearn
import warnings
warnings.filterwarnings("ignore")
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler,LabelEncoder
from sklearn.model_selection import train_test_split,cross_val_score, KFold
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB, MultinomialNB,BernoulliNB
from sklearn.svm import LinearSVC, SVC
from sklearn import metrics
from sklearn.metrics import confusion_matrix, classification_report
# %matplotlib inline

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# Reading the dataset
filename='/content/top50.csv'
df=pd.read_csv(filename,encoding='ISO-8859-1')
df.head()

# Renaming the columns
#Datatypes of the columns
#track_name           String  :Name of the Track
#artist_name          String  :Name of the Artist
#Genre                String  :The genre of the track
#beats_per_minute     integer :The tempo of the song.
#Energy               integer :The energy of a song - the higher the value, the more energtic the song
#Danceability         integer :The higher the value, the easier it is to dance to this song.
#Loudness(dB)         integer :The higher the value, the louder the song.
#Liveness             integer :The higher the value, the more likely the song is a live recording.
#Valence              integer :The higher the value, the more positive mood for the song.
#Length               integer :The duration of the song.
#Acousticness         integer :The higher the value the more acoustic the song is.
#Speechiness          integer :The higher the value the more spoken word the song contains.
#Popularity           integer :The higher the value the more popular the song is. Thus the number of streams.
df.rename(columns={'Track.Name':'track_name','Artist.Name':'artist_name','Beats.Per.Minute':'beats_per_minute','Loudness..dB..':'Loudness(dB)','Valence.':'Valence','Length.':'Length', 'Acousticness..':'Acousticness','Speechiness.':'Speechiness'},inplace=True)

# Analysing the relationship between energy and loudness using linear regression
fig=plt.subplots(figsize=(10,10))
sns.regplot(x='Energy',y='Loudness(dB)',data=df,color='black')

# Analysing the relationship between popularity and valence using linear regression
fig=plt.subplots(figsize=(10,10))
sns.regplot(x='Valence',y='Popularity',data=df,color='black')

# Analysing the relationship between popularity and energy using kernel density estimation
fig=plt.subplots(figsize=(10,10))
plt.title('Dependence between energy and popularity')
sns.regplot(x='Energy', y='Popularity',
            ci=None, data=df)
sns.kdeplot(df.Energy,df.Popularity)

# Analysing the relationship between popularity and liveness using kernel density estimation
fig=plt.subplots(figsize=(10,10))
plt.title('Dependence between liveness and popularity')
sns.regplot(x='Liveness', y='Popularity',
            ci=None, data=df)
sns.kdeplot(df.Liveness,df.Popularity)

# heatmap of the correlation 
pd.set_option('display.width', 100)
pd.set_option('precision', 3)
correlation=df.corr(method='spearman')
plt.figure(figsize=(10,10))
plt.title('Correlation heatmap')
sns.heatmap(correlation,annot=True,vmin=-1,vmax=1,cmap="GnBu_r",center=1)